java变量类型：基本数据类型：

数值型：byte short long float double 字符型：char 布尔型:   boolean

引用数据类型： 类class  包含字符串 接口interface  数组([])

##### 4.1 面对对象三大主线

1.Java类及类的成员

2.面对对象的三大特征：封装 继承 多态 

3.其他关键字this super static final abstract interface package import

面对对象和面向过程：

面对过程：强调功能行为，以函数为最小单位，强调怎么做

面对对象：将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

##### 4.2 类和对象

类的成员包括属性和方法

属性：成员变量

方法：成员函数

##### 4.3对象的创建与使用：内存解析

堆区：存放对象实例 new

虚拟机栈：局部变量 形参

方法区：常量、静态常量、编译后的代码

类中成员变量和局部变量的区分：成员变量在class {}内，可以使用权限修饰符；局部变量在方法内，或者是形参，或者构造器内 构造器形参

##### 4.4 匿名对象

new class名().方法()；  .属性

只能调用一次，开发中将匿名对象用作函数的形参

##### 4.5 重载

同一个类 相同方法名 

参数列表不同 参数个数不同 参数类型不同

与权限修饰符 返回值类型 形参变量名 方法体无关

##### 4.6 值传递

值传递机制：

如果是基本数据类型，此时赋值的是变量所保存的数据值；如果是引用数据类型（null或地址值），此时赋值的是变量所保存的数据的地址值，比如new的对象

##### 4.7 封装和隐藏

创建一个类的对象之后，用对象.属性的方式进行赋值，此时只有数据类型和存储范围的限制。但是实际问题中属性赋值时有限制条件，这个不能在属性声明时体现，就需要用方法进行限制。（比如年龄不能为负值）

要避免用对象.属性的方式进行赋值，将属性声明为私有，用公共的方法来获取和设置属性的值。此时就体现了封装性。

四种权限修饰符

private 缺省 protected public

public可以任意访问 default只能在同一个包内部的类访问

![image-20220424113823988](C:\Typora\mylearning\img\image-20220424113823988.png)

 修饰类只能用缺省和public

出了类，private的属性就不能被访问；出了包，缺省不能访问；

总结封装性：java提供四种权限修饰修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性。

##### 4.8 类的成员之三：构造器

构造器的作用：

1.创建对象  new+构造器   new Person()

2.给对象初始化，初始化对象的信息

如果没有显式定义构造器，系统默认提供一个空的构造器；

定义构造器的格式：权限修饰符 类名（形参列表）{}

一个类中多个构造器构成重载；一旦定义了构造器，就不再提供默认构造；一个类至少需要一个构造器。

拓展：JavaBean的三个条件：1、类是公共的 2、有一个无参的公共的构造器 3、有属性、且有对应的get、set方法。

 UML类图：根据图写出类

##### 4.9 this的使用

一般情况省略this；特殊情况当类的属性和方法的形参同名，用this.属性表示是该类的属性，而非形参

构造器内调用另一个构造器 this(形参)，不能调用自己，或者避免调用成环，陷入循环。

##### 5.1 继承

class A extends B

A:subclass     B:superclass

优点：1.减少代码荣誉，提高复用性  2. 便于动态扩展  3. 为之后多态的使用提供前提。

体现：父类中private的属性或方法，子类仍然获取了父类私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构。

java中的继承性：如果没有显式的声明一个类的父类，则此类继承于java.lang.Object类。所有类都直接或间接地继承于此类。

##### 5.2 方法的重写

子类对父类继承的方法进行改造，对父类同名同参数的方法进行覆盖。

应用：重写之后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法。

##### 5.3 方法重写的细节 

子类重写方法的权限修饰符不小于父类被重写的方法的权限修饰符，子类不能重写父类中private权限的方法

子类重写的方法抛出的异常不大于父类被重写的方法抛出的异常类型

重写时父类和子类要么都声明为static，要么都声明为非static

父类被重写的方法返回类型是A类，子类重写的方法的返回类型必须是A或者A的子类

##### 5.4 关键字super

super关键字：可以理解为父类的

super可以用来调用：属性、方法、构造器

一般情况下省略super。当子类父类中出现了同名的属性，在子类中使用 super.属性 显式地调用父类的属性

this(形参列表)：调用本类重载的构造器

super调用构造器： super(参数1，参数2)；

1、可以在子类的构造器中显式的使用上述方式调用父类中声明的指定构造器。

2、super必须声明在子类构造器的首行

3、在类的构造器中，this(形参列表)或super(形参列表)只能二选1

4、在子类构造器的首行没有显式的声明的时候默认调用super();

##### 5.5 子类对象实例化的过程

从结果上看：子类继承父类，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载父类中声明的属性。

从过程上看，当通过子类的构造器创建子类对象时，一定会直接或间接地调用父类的构造器，父类的父类的...直到java.lang.Object类中的空参构造器。

![image-20220426150104706](C:\Typora\mylearning\\img\image-20220426150104706.png)

##### 5.6 多态性

- 理解：一个事物的多种形态

```java
class Person() {}
class Man extends Person {}
main(){
    //对象的多态性：父类的引用指向子类的对象
    Person p = new Man();
}
```

- 多态的使用：

  当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法-------虚拟方法调用

编译期只能调用父类声明的方法，在运行期，实际执行的是子类重写父类的方法。编译看左边，运行看右边

- 多态的使用前提：继承 方法的重写

多态使用实例：

```java
class AnimalTest(){
    main(){
        AnimalTest test = new AnimalTest();
        test.func(new Dog());
        //此时运行的是Dog的函数
    } 
    //没有多态性就不能调用子类重写的方法，就需要进行方法的重载
    func(Animal animal){ //Animal animal = new Dog()
        animal.eat();
        animal.shout();
    }
}
class Animal(){
    eat(){};
    shout(){};
}
class Dog extends Animal{
    eat(){};
    shout(){};
}
class Cat extends Animal{
    eat(){};
    shout(){};
}
```

多态不适用于属性，只适用于方法

- 动态绑定：多态是编译时行为还是运行时行为？运行时行为，运行时才知道new的对象是什么

编译时为Animal类型，而方法的调用是在运行时确定的，所以调用的是new子类中的方法。

- 方法的重载和重写：

从编译和运行角度：重载：方法调用之前，编译器就确定了要使用的方法。早绑定或静态绑定

多态：方法调用的那一刻，编译器才确定要调用的方法。晚绑定或动态绑定

- 补充：instanceof操作符

x instanceof A：检验x是否为类A的对象，返回值为boolean

要求x所属的类与类A必须是子类和父类的关系，否则编译错误；如果x属于类A的子类B，x instanceof A也为true

有了对象的多态性，内存中实际上是加载了子类特有的属性和方法，但是由于声明为父类类型，导致，编译时，只能调用父类中声明的属性和方法。 如何才能调用子类特有的属性和方法？向下转型：使用强制类型转换符。

为了避免使用强制转换时出现异常，一般先用x instanceof A进行判断。

  向上转型：多态    

Person p = new Man();       Man m = Man(p);

##### 5.7 Object类的使用

- Object类是所有Java类的根父类

- ==运算符：

1、基本数据类型变量，比较两个变量值是否相等（不一定类型相同）。

2、引用数据类型变量，比较两个对象的地址是否相同，即两个引用是否指向同一个对象实体。

3、符号使用时，必须保证符号两边的变量类型一致。

- equals()方法的使用：

1、只能适用于引用数据类型

2、Object类中equals()的定义和==作用是相同的。

3、像String Date File 包装类都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址， 而是比较两个对象的实体内容是否相同。

4、通常情况下我们自定义的类要使用equals()的话，也是通常比较两个对象的实体内容是否相同， 就需要对Object类中的equals()进行重写。

5、重写前比较引用类型的地址，重写后比较内容

总结：比较基本数据类型用==，比较引用数据类型用equals()

- toString()方法

Object类中toString()的使用：

1、当输出一个对象的引用时，实际上就是调用当前对象的toString()

2、Object类中toString()的定义就是输出地址（虚拟地址）

3、String、Date、File、包装类都重写过toString()方法，使得在调用对象的toString()时2，返回实体内容信息。

4、自定义类也可以重写toString() 方法。

##### 5.8 包装类的使用

封装类 

![1651216961713](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1651216961713.png)

 包装类的使用：

1、Java提供了8中数据类型对应的包装类，使得基本数据类型的变量具有类的特征

2、  **重点**：基本类型、包装类与String类三者间的转换

```java
//基本数据类型---->包装类：调用包装类的构造器
int num1 =10;
Integer in1 = new Integer(num1);
//包装类----->基本数据类型：调用包装类的xxxValue()
Integer in1 = new Integer(12);
int i1 = i1.intalue();
//JDK5.0新特性：自动装箱与拆箱
//自动装箱
int num2 = 10;
Integer in2 = num2;直接转为包装类
//自动拆箱
int num3 = in1;包装类直接转为基本类型
```

```java
//基本数据类型、包装类--->String类型
//方式一 ：
int num1 = 10;
String str1 = num1 + "";
//方式二：使用String重载的Valueof(xxx)
float f1 = 3.2f;
String s1 = String.valueOf(f1);
//String类---->基本数据类型、包装类
//错误示例：
String srt1 = "123";
int num1 = int(str1);
Integer in1 = (Integer)str1;不能强转，没有子父类关系。
//调用包装类的parsexxx()方法
Integer.parseInt(str1);
```

重点：自动拆箱装箱 valueOf()   parsexxx()方法

##### 6.1 关键字static

编写类时，其实就是描述其对象的属性和行为，而并没有产生实质的对象，只有new关键字才会产生出对象，这时系统才会分配内存给对象，其方法才能供外部调用。

有时希望无论是否产生对象，某些特定的数据在内存空间里只有一份，例如每个中国人都有统一的国家，不必在每个人的实例对象中都单独分配一个用于代表国家的变量。

1、static:静态的

2、static可以用来修饰：属性、方法、代码块、内部类

3、使用static修饰属性：静态变量（类变量）

​	3.1、属性按照是否用static修饰分为 静态属性 VS非静态属性（实例变量）

​	实例变量：创建类的多个对象，每个对象都有一套类中的非静态属性，当修改某个对象的非静态属性时，不会影响其他对象的属性值。

​	静态变量：创建类的多个对象，每个对象都共享同一个静态变量。修改某个对象的静态变量，其他对象调用时是修改过的。

​	3.2、static修饰属性的其他说明：

​	静态变量随着类的加载而加载

​	静态变量的加载要早于对象的创建

​	由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中。

​	是否调用		类变量     		实例变量

​	类						√						×

​	对象					√						√

​	3.3、静态常量举例：System.out；Math.PI；

![image-20220505114212067](C:\Typora\mylearning\\img\image-20220505114212067.png)

4、使用static修饰方法：

随着类的加载而加载，通过类.静态方法的方式进行调用，无需创建对象
    是否调用		静态方法     	非静态方法
 	类			             √		      		×
 	对象	  		       √			     	√
	 静态方法中只能调用静态的方法和属性；非静态方法中既可以调用非静态方法属性，也可以调用静态方法属性。

5、static注意点：

	> 5.1、在静态的方法内，不能使用this关键字、super关键字
	>因为静态是基于类的，还没有对象；this和super都是基于对象
	> 5.2、关于静态属性和静态方法的使用，都从生命周期的角度去理解。

6、开发中，如何确定一个属性是否声明为static？

	> 属性可以被多个对象共享，不会随着对象的不同而不同。

​	   开发中，如何确定一个方法是否声明为static？

​	操作静态属性的方法，通常设置为static

​	工具类中的方法，习惯上声明为static。比如Math类、Arrays

设计模式：在大量的时间中总结和理论化之后优选的代码风格、编程风格以及解决问题的思考方式。套路

![1651287712510](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1651287712510.png)

单例设计模式：采取一定方式保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

如何实现？

```java
//1、饿汉式实现:一开始就造好
///不让用户去自主的创建实例对象，而是自己创建好实例对象，让用户通过设置好的方法去调用
class Bank() {
	//1、私有化类的构造器
	private Bank(){}
    //2、内部创建类的对象
    private static Bank instance = new Bank();
    //3、提供公共静态方法返回类的对象
    //要求只能通过类调用＋static
    public static Bank getInstace(){
        return instance;
    }
    //4、要求此对象也必须声明为static
}
//2、懒汉式实现:什么时候用什么时候造
class Order(){
    //1、私有化类的构造器
    private Order(){      
    }
    //2、声明当前类的对象，没有初始化
    private static Order instance = null;
    //3、声明public的static的返回当前类对象的方法
    public Order getInstance(){
        if(instance == null) {
         	instance = new Order();   
        }
        return instance;
    }
    //4、此对象必须为static
}
```

3、区分饿汉式和懒汉式
饿汉式：坏处：导致对象加载时间过长
	           好处：饿汉式是线程安全的,只有一份，谁取谁用
懒汉式：好处：延迟对象的创建
		       坏处：线程不安全。阻塞时可能会导致多个对象创建

##### 6.2 理解main方法的语法

 程序的入口 为什么加static？ 

因为可以通过类调用，不用通过对象调用。[static](https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020)是静态的，系统类刚加载的时候不能创建对象，没办法用对象调用。

同时，对象调用的话，这个类要有构造，构造又可以被重载。如果重载了之后，会有多个main方法，则main方法不能作为唯一入口

##### 6.3 类的成员之四：代码块

 代码块（初始化块）  表示：{}

1、代码块的作用：用来初始化类，对象

2、代码块如果有修饰的话，只能使用static

3、分类：静态代码块 VS 非静态代码块

静态代码块：static{}

​		内部可以有输出语句

​		随着类的加载而执行

作用：初始化类的信息

​		静态代码块的执行要优先于非静态代码块的执行

非静态代码块：

​		内部可以有输出语句

​		随着对象的创建而执行，每创建一个对象就执行一次非静态代码块 

​		作用：可以在创建对象时 对 对象的属性初始化

执行顺序原则：由父及子，静态先行

没创建对象时先执行静态代码块，顺序都是由父及子。

对属性可以赋值的位置：

①默认初始化

②显式初始化/⑤在代码块中赋值

③构造器中初始化

④有对象之后，通过对象.属性的方式进行赋值

执行的先后顺序：① - ②/⑤ - ③ - ④

##### 6.4 关键字：final 

1、final可以修饰的结构：类、方法、变量

2、final修饰类，此类不能被其他类继承，是最后一代

final class A{

}

3、final修饰方法表明此方法不能被重写

4、final修饰变量，此时的变量就是一个常量

​	4.1、final修饰属性，可以考虑赋值的位置有显式初始化、代码块赋值，构造器中赋值。  

​	4.2、final修饰局部变量：修饰形参表示该形参是常量，赋值以后不能重新赋值。

5、static final 用来修饰属性：全局常量

​		修饰方法

##### 6.5 抽象类与抽象方法

将父类设计的非常抽象，以至于他没有具体的实例，这样的类叫做抽象类。

关键字abstract 使用前提：继承性

可以用来修饰：类、方法

1、抽象类：

​	不能实例化

​	一定有构造器，便于子类实例化时使用，

​	开发中都会提供抽象类的子类。让子类实例化

2、抽象方法：

​	只有方法的声明，没有方法体。

​	抽象类可以没有抽象方法，包含抽象方法的类一定是抽象类。

​	若子类重写了父类所有的抽象方法，则可以实例化；若没有，则子类也是抽象类。

3、抽象类的应用：当对象不清晰时，可以抽象处理并在子类中实例化

4、抽象类的匿名子类:

 Person p = new Person(){

​	重写的方法；

};

5、多态应用：模板方法设计模式

抽象类就是一种模板模式的设计，抽象类作为子类的通用模板，子类在抽象类的基础上进行扩展改造，但子类总体保留抽象类的行为模式。

##### 6.6 接口（interface）

利用接口实现多重继承（子类继承多个父类）

class AA extends BB implements CC,DD,EE;

1、关键字interface

2、java中接口和类是并列的两个结构

3、如何定义接口：定义接口中的成员

​	3.1、JDK7及以前：只能定义全局常量和抽象方法

​	>全局常量：public static final

​	>抽象方法：public abstract

​	3.2、JDK8：除了全局常量和抽象方法，还可以定义静态方法、默认方法

4、接口中不能定义构造器，意味着不能实例化

5、接口通过让类去实现（implements）的方式来使用

​	如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化

​	Java类可以实现多个接口

6、接口的应用：

​	代理模式  为其他对象提供一种代理以控制对这个对象的访问。

​	工厂模式：实现创建者与调用者的分离，即将创建对象的具体过程被屏蔽隔离起来，达到提高灵活性的目的。

​	分类：无工厂模式、简单工厂模式、工厂方法模式、抽象工厂模式 

7、Java8关于接口的新规范

##### 6.7类的成员之五：内部类

事物的内部，某个部分需要一个完整的结构进行描述，这个结构又只为外部事物提供服务，最好使用内部类。

inner class在外部引用时必须给出完整的名称。

分类： 成员内部类（static和非static）

​			局部内部类（方法内、块内、构造器内）

##### 7.1 异常概述与异常体系结构

异常事件：

1、Error:Java虚拟机无法解决的严重问题，一般不编写代码进行处理。如：JVM系统内部错误、资源耗尽等严重清空。比如StackOverFlow和OOM  OutOfMemory 栈溢出和堆溢出

2、Exception:可以进行处理的问题。如：空指针访问、读取不存在的文件、网络中断、数组越界

##### 7.2 常见异常

​	编译时异常（checked）和运行时异常（unchecked）RunTimeException

##### 7.3 异常处理机制一：try-catch-finally

异常的处理：抓抛模型

过程一：抛 程序执行时，一旦出现异常就在异常代码出生成一个对应异常类的对象，并将此对象抛出。抛出后后面的代码不再执行。

过程二：抓 两种处理机制

```java
//try-catch-finally
try{
	//可能出现异常的代码
}catch(异常类型1 变量名1){
	//处理异常的方式1
}catch(异常类型2 变量名3){
	//处理异常的方式2
}
...
finally{
    //一定会执行的代码
}
//像数据库连接、输入输出流、网络编程socket等，JVM是不能制动回收的，这时候需要手动释放，此时资源的释放就要被声明在finally中。
//显示异常
printStackTrace()
```



##### 7.4 异常处理机制二：throws

:dog

##### 7.5 手动抛出异常：throw

 

##### 7.6 用户自定义异常类



​    

  